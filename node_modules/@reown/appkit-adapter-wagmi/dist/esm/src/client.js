import { connect, createConfig, getAccount, getBalance, getConnections, injected, prepareTransactionRequest, reconnect, signMessage, switchChain, disconnect as wagmiDisconnect, estimateGas as wagmiEstimateGas, sendTransaction as wagmiSendTransaction, writeContract as wagmiWriteContract, waitForTransactionReceipt, watchAccount, watchConnectors, watchPendingTransactions } from '@wagmi/core';
import {} from '@wagmi/core/chains';
import { formatUnits, parseUnits } from 'viem';
import { AppKit } from '@reown/appkit';
import { ConstantsUtil as CommonConstantsUtil, NetworkUtil } from '@reown/appkit-common';
import { CoreHelperUtil, StorageUtil } from '@reown/appkit-controllers';
import {} from '@reown/appkit-controllers';
import { CaipNetworksUtil, PresetsUtil } from '@reown/appkit-utils';
import { AdapterBlueprint } from '@reown/appkit/adapters';
import { WalletConnectConnector } from '@reown/appkit/connectors';
import { authConnector } from './connectors/AuthConnector.js';
import { walletConnect } from './connectors/UniversalConnector.js';
import { LimitterUtil } from './utils/LimitterUtil.js';
import { getCoinbaseConnector, getSafeConnector, parseWalletCapabilities } from './utils/helpers.js';
const DEFAULT_PENDING_TRANSACTIONS_FILTER = {
    enable: false,
    pollingInterval: 30_000
};
export class WagmiAdapter extends AdapterBlueprint {
    constructor(configParams) {
        const networks = CaipNetworksUtil.extendCaipNetworks(configParams.networks, {
            projectId: configParams.projectId,
            customNetworkImageUrls: {},
            customRpcUrls: configParams.customRpcUrls
        });
        super();
        this.balancePromises = {};
        this.namespace = CommonConstantsUtil.CHAIN.EVM;
        this.adapterType = CommonConstantsUtil.ADAPTER_TYPES.WAGMI;
        this.projectId = configParams.projectId;
        this.pendingTransactionsFilter = {
            ...DEFAULT_PENDING_TRANSACTIONS_FILTER,
            ...(configParams.pendingTransactionsFilter ?? {})
        };
        this.createConfig({ ...configParams, networks });
        this.checkChainId();
    }
    construct(_options) {
        this.checkChainId();
        this.setupWatchers();
    }
    async getAccounts(params) {
        const connector = this.getWagmiConnector(params.id);
        if (!connector) {
            return { accounts: [] };
        }
        if (connector.id === CommonConstantsUtil.CONNECTOR_ID.AUTH) {
            const provider = (await connector.getProvider());
            if (!provider?.user) {
                return { accounts: [] };
            }
            const { address, accounts } = provider.user;
            return Promise.resolve({
                accounts: (accounts || [{ address, type: 'eoa' }]).map(account => CoreHelperUtil.createAccount('eip155', account.address, account.type))
            });
        }
        const { addresses, address } = getAccount(this.wagmiConfig);
        return Promise.resolve({
            accounts: [...new Set(addresses || [address])]?.map(val => CoreHelperUtil.createAccount('eip155', val || '', 'eoa'))
        });
    }
    checkChainId() {
        const { chainId } = getAccount(this.wagmiConfig);
        if (chainId) {
            this.emit('switchNetwork', {
                chainId
            });
        }
    }
    getWagmiConnector(id) {
        return this.wagmiConfig.connectors.find(c => c.id === id);
    }
    createConfig(configParams) {
        this.wagmiChains = configParams.networks.filter(caipNetwork => caipNetwork.chainNamespace === CommonConstantsUtil.CHAIN.EVM);
        const transports = {};
        const connectors = [...(configParams.connectors ?? [])];
        this.wagmiChains.forEach(element => {
            const fromTransportProp = configParams.transports?.[element.id];
            const caipNetworkId = CaipNetworksUtil.getCaipNetworkId(element);
            if (fromTransportProp) {
                transports[element.id] = CaipNetworksUtil.extendWagmiTransports(element, configParams.projectId, fromTransportProp);
            }
            else {
                transports[element.id] = CaipNetworksUtil.getViemTransport(element, configParams.projectId, configParams.customRpcUrls?.[caipNetworkId]);
            }
        });
        this.wagmiConfig = createConfig({
            ...configParams,
            chains: this.wagmiChains,
            connectors,
            transports
        });
    }
    setupWatchPendingTransactions() {
        if (!this.pendingTransactionsFilter.enable || this.unwatchPendingTransactions) {
            return;
        }
        this.unwatchPendingTransactions = watchPendingTransactions(this.wagmiConfig, {
            pollingInterval: this.pendingTransactionsFilter.pollingInterval,
            onError: () => { },
            onTransactions: () => {
                this.emit('pendingTransactions');
                LimitterUtil.increase('pendingTransactions');
            }
        });
        const unsubscribe = LimitterUtil.subscribeKey('pendingTransactions', val => {
            if (val >= CommonConstantsUtil.LIMITS.PENDING_TRANSACTIONS) {
                this.unwatchPendingTransactions?.();
                unsubscribe();
            }
        });
    }
    setupWatchers() {
        watchAccount(this.wagmiConfig, {
            onChange: (accountData, prevAccountData) => {
                if (accountData.status === 'disconnected' && prevAccountData.address) {
                    this.emit('disconnect');
                }
                if (accountData?.chainId && accountData?.chainId !== prevAccountData?.chainId) {
                    this.emit('switchNetwork', {
                        chainId: accountData.chainId
                    });
                }
                if (accountData.status === 'connected') {
                    if (accountData.address !== prevAccountData?.address ||
                        prevAccountData.status !== 'connected') {
                        this.setupWatchPendingTransactions();
                        this.emit('accountChanged', {
                            address: accountData.address,
                            chainId: accountData.chainId
                        });
                    }
                }
            }
        });
    }
    async addThirdPartyConnectors(options) {
        const thirdPartyConnectors = [];
        if (options.enableCoinbase !== false) {
            const coinbaseConnector = await getCoinbaseConnector(this.wagmiConfig.connectors);
            if (coinbaseConnector) {
                thirdPartyConnectors.push(coinbaseConnector);
            }
        }
        const safeConnector = await getSafeConnector(this.wagmiConfig.connectors);
        if (safeConnector) {
            thirdPartyConnectors.push(safeConnector);
        }
        await Promise.all(thirdPartyConnectors.map(connector => {
            const cnctr = this.wagmiConfig._internal.connectors.setup(connector);
            this.wagmiConfig._internal.connectors.setState(prev => [...prev, cnctr]);
            return this.addWagmiConnector(cnctr, options);
        }));
    }
    addWagmiConnectors(options, appKit) {
        const customConnectors = [];
        if (options.enableWalletConnect !== false) {
            customConnectors.push(walletConnect(options, appKit));
        }
        if (options.enableInjected !== false) {
            customConnectors.push(injected({ shimDisconnect: true }));
        }
        const isEmailEnabled = appKit?.remoteFeatures?.email ?? true;
        const socialsEnabled = Array.isArray(appKit?.remoteFeatures?.socials) && appKit?.remoteFeatures?.socials?.length > 0;
        if (isEmailEnabled || socialsEnabled) {
            customConnectors.push(authConnector({
                chains: this.wagmiChains,
                options: { projectId: options.projectId, enableAuthLogger: options.enableAuthLogger }
            }));
        }
        customConnectors.forEach(connector => {
            const cnctr = this.wagmiConfig._internal.connectors.setup(connector);
            this.wagmiConfig._internal.connectors.setState(prev => [...prev, cnctr]);
        });
    }
    async signMessage(params) {
        try {
            const signature = await signMessage(this.wagmiConfig, {
                message: params.message,
                account: params.address
            });
            return { signature };
        }
        catch (error) {
            throw new Error('WagmiAdapter:signMessage - Sign message failed');
        }
    }
    async sendTransaction(params) {
        const { chainId, address } = getAccount(this.wagmiConfig);
        const txParams = {
            account: address,
            to: params.to,
            value: Number.isNaN(Number(params.value)) ? BigInt(0) : BigInt(params.value),
            gas: params.gas ? BigInt(params.gas) : undefined,
            gasPrice: params.gasPrice ? BigInt(params.gasPrice) : undefined,
            data: params.data,
            chainId,
            type: 'legacy',
            parameters: ['nonce']
        };
        await prepareTransactionRequest(this.wagmiConfig, txParams);
        const tx = await wagmiSendTransaction(this.wagmiConfig, txParams);
        await waitForTransactionReceipt(this.wagmiConfig, { hash: tx, timeout: 25000 });
        return { hash: tx };
    }
    async writeContract(params) {
        const { caipNetwork, ...data } = params;
        const chainId = Number(NetworkUtil.caipNetworkIdToNumber(caipNetwork.caipNetworkId));
        const tx = await wagmiWriteContract(this.wagmiConfig, {
            chain: this.wagmiChains?.[chainId],
            chainId,
            address: data.tokenAddress,
            account: data.fromAddress,
            abi: data.abi,
            functionName: data.method,
            args: data.args,
            __mode: 'prepared'
        });
        return { hash: tx };
    }
    async estimateGas(params) {
        try {
            const result = await wagmiEstimateGas(this.wagmiConfig, {
                account: params.address,
                to: params.to,
                data: params.data,
                type: 'legacy'
            });
            return { gas: result };
        }
        catch (error) {
            throw new Error('WagmiAdapter:estimateGas - error estimating gas');
        }
    }
    parseUnits(params) {
        return parseUnits(params.value, params.decimals);
    }
    formatUnits(params) {
        return formatUnits(params.value, params.decimals);
    }
    async addWagmiConnector(connector, options) {
        if (connector.id === CommonConstantsUtil.CONNECTOR_ID.AUTH ||
            connector.id === CommonConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
            return;
        }
        const provider = (await connector.getProvider().catch(() => undefined));
        this.addConnector({
            id: connector.id,
            explorerId: PresetsUtil.ConnectorExplorerIds[connector.id],
            imageUrl: options?.connectorImages?.[connector.id] ?? connector.icon,
            name: PresetsUtil.ConnectorNamesMap[connector.id] ?? connector.name,
            imageId: PresetsUtil.ConnectorImageIds[connector.id],
            type: PresetsUtil.ConnectorTypesMap[connector.type] ?? 'EXTERNAL',
            info: connector.id === CommonConstantsUtil.CONNECTOR_ID.INJECTED
                ? undefined
                : { rdns: connector.id },
            provider,
            chain: this.namespace,
            chains: []
        });
    }
    async syncConnectors(options, appKit) {
        watchConnectors(this.wagmiConfig, {
            onChange: connectors => {
                connectors.forEach(connector => this.addWagmiConnector(connector, options));
            }
        });
        this.addWagmiConnectors(options, appKit);
        await Promise.all(this.wagmiConfig.connectors.map(connector => this.addWagmiConnector(connector, options)));
        this.addThirdPartyConnectors(options);
    }
    async syncConnection(params) {
        const { id, chainId } = params;
        const connections = getConnections(this.wagmiConfig);
        const connection = connections.find(c => c.connector.id === id);
        const connector = this.getWagmiConnector(id);
        const provider = (await connector?.getProvider());
        const isSafeApp = CoreHelperUtil.isSafeApp();
        if (isSafeApp && id === CommonConstantsUtil.CONNECTOR_ID.SAFE && !connection?.accounts.length) {
            const safeAppConnector = this.getWagmiConnector('safe');
            if (safeAppConnector) {
                const res = await connect(this.wagmiConfig, {
                    connector: safeAppConnector,
                    chainId: Number(chainId)
                });
                const safeProvider = (await safeAppConnector.getProvider());
                return {
                    chainId: Number(chainId),
                    address: res.accounts[0],
                    provider: safeProvider,
                    type: connection?.connector.type?.toUpperCase(),
                    id: connection?.connector.id
                };
            }
        }
        return {
            chainId: Number(connection?.chainId),
            address: connection?.accounts[0],
            provider,
            type: connection?.connector.type?.toUpperCase(),
            id: connection?.connector.id
        };
    }
    async connectWalletConnect(chainId) {
        const walletConnectConnector = this.getWalletConnectConnector();
        await walletConnectConnector.authenticate();
        const wagmiConnector = this.getWagmiConnector('walletConnect');
        if (!wagmiConnector) {
            throw new Error('UniversalAdapter:connectWalletConnect - connector not found');
        }
        const res = await connect(this.wagmiConfig, {
            connector: wagmiConnector,
            chainId: chainId ? Number(chainId) : undefined
        });
        if (res.chainId !== Number(chainId)) {
            await switchChain(this.wagmiConfig, { chainId: res.chainId });
        }
        return { clientId: await walletConnectConnector.provider.client.core.crypto.getClientId() };
    }
    async connect(params) {
        const { id, provider, type, info, chainId, socialUri } = params;
        const connector = this.getWagmiConnector(id);
        if (!connector) {
            throw new Error('connectionControllerClient:connectExternal - connector is undefined');
        }
        if (provider && info && connector.id === CommonConstantsUtil.CONNECTOR_ID.EIP6963) {
            connector.setEip6963Wallet?.({ provider, info });
        }
        if (connector.uid === this.wagmiConfig?.state?.current) {
            const connection = this.wagmiConfig.state?.connections?.get(connector.uid);
            if (connection) {
                return {
                    address: connection?.accounts[0],
                    chainId: connection?.chainId,
                    provider: provider,
                    type: type,
                    id
                };
            }
        }
        const res = await connect(this.wagmiConfig, {
            connector,
            chainId: chainId ? Number(chainId) : undefined,
            socialUri
        });
        return {
            address: res.accounts[0],
            chainId: res.chainId,
            provider: provider,
            type: type,
            id
        };
    }
    async reconnect(params) {
        const { id } = params;
        const connector = this.getWagmiConnector(id);
        if (!connector) {
            throw new Error('connectionControllerClient:connectExternal - connector is undefined');
        }
        await reconnect(this.wagmiConfig, {
            connectors: [connector]
        });
    }
    async getBalance(params) {
        const address = params.address;
        const caipNetwork = this.getCaipNetworks().find(network => network.id === params.chainId);
        if (!address) {
            return Promise.resolve({ balance: '0.00', symbol: 'ETH' });
        }
        if (caipNetwork && this.wagmiConfig) {
            const caipAddress = `${caipNetwork.caipNetworkId}:${params.address}`;
            const cachedPromise = this.balancePromises[caipAddress];
            if (cachedPromise) {
                return cachedPromise;
            }
            const cachedBalance = StorageUtil.getNativeBalanceCacheForCaipAddress(caipAddress);
            if (cachedBalance) {
                return { balance: cachedBalance.balance, symbol: cachedBalance.symbol };
            }
            this.balancePromises[caipAddress] = new Promise(async (resolve) => {
                try {
                    const chainId = Number(params.chainId);
                    const balance = await getBalance(this.wagmiConfig, {
                        address: params.address,
                        chainId,
                        token: params.tokens?.[caipNetwork.caipNetworkId]?.address
                    });
                    StorageUtil.updateNativeBalanceCache({
                        caipAddress,
                        balance: balance.formatted,
                        symbol: balance.symbol,
                        timestamp: Date.now()
                    });
                    resolve({ balance: balance.formatted, symbol: balance.symbol });
                }
                catch (error) {
                    console.warn('Appkit:WagmiAdapter:getBalance - Error getting balance', error);
                    resolve({ balance: '0.00', symbol: 'ETH' });
                }
            }).finally(() => {
                delete this.balancePromises[caipAddress];
            });
            return this.balancePromises[caipAddress] || { balance: '0.00', symbol: 'ETH' };
        }
        return { balance: '', symbol: '' };
    }
    getWalletConnectProvider() {
        return this.getWagmiConnector('walletConnect')?.['provider'];
    }
    async disconnect() {
        const connections = getConnections(this.wagmiConfig);
        await Promise.allSettled(connections.map(async (connection) => {
            const connector = this.getWagmiConnector(connection.connector.id);
            if (connector) {
                await wagmiDisconnect(this.wagmiConfig, { connector });
            }
        }));
        this.wagmiConfig.state.connections.clear();
    }
    async switchNetwork(params) {
        const { caipNetwork } = params;
        await switchChain(this.wagmiConfig, {
            chainId: caipNetwork.id,
            addEthereumChainParameter: {
                chainName: caipNetwork.name,
                nativeCurrency: caipNetwork.nativeCurrency,
                rpcUrls: [caipNetwork.rpcUrls?.['chainDefault']?.http?.[0] ?? ''],
                blockExplorerUrls: [caipNetwork.blockExplorers?.default.url ?? ''],
                iconUrls: [caipNetwork.assets?.imageUrl ?? '']
            }
        });
        await super.switchNetwork(params);
    }
    async getCapabilities(params) {
        if (!this.wagmiConfig) {
            throw new Error('connectionControllerClient:getCapabilities - wagmiConfig is undefined');
        }
        const connections = getConnections(this.wagmiConfig);
        const connection = connections[0];
        const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
        if (!connector) {
            throw new Error('connectionControllerClient:getCapabilities - connector is undefined');
        }
        const provider = (await connector.getProvider());
        if (!provider) {
            throw new Error('connectionControllerClient:getCapabilities - provider is undefined');
        }
        const walletCapabilitiesString = provider.session?.sessionProperties?.['capabilities'];
        if (walletCapabilitiesString) {
            const walletCapabilities = parseWalletCapabilities(walletCapabilitiesString);
            const accountCapabilities = walletCapabilities[params];
            if (accountCapabilities) {
                return accountCapabilities;
            }
        }
        return await provider.request({ method: 'wallet_getCapabilities', params: [params] });
    }
    async grantPermissions(params) {
        if (!this.wagmiConfig) {
            throw new Error('connectionControllerClient:grantPermissions - wagmiConfig is undefined');
        }
        const connections = getConnections(this.wagmiConfig);
        const connection = connections[0];
        const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
        if (!connector) {
            throw new Error('connectionControllerClient:grantPermissions - connector is undefined');
        }
        const provider = (await connector.getProvider());
        if (!provider) {
            throw new Error('connectionControllerClient:grantPermissions - provider is undefined');
        }
        return provider.request({ method: 'wallet_grantPermissions', params });
    }
    async revokePermissions(params) {
        if (!this.wagmiConfig) {
            throw new Error('connectionControllerClient:revokePermissions - wagmiConfig is undefined');
        }
        const connections = getConnections(this.wagmiConfig);
        const connection = connections[0];
        const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
        if (!connector) {
            throw new Error('connectionControllerClient:revokePermissions - connector is undefined');
        }
        const provider = (await connector.getProvider());
        if (!provider) {
            throw new Error('connectionControllerClient:revokePermissions - provider is undefined');
        }
        return provider.request({ method: 'wallet_revokePermissions', params });
    }
    async walletGetAssets(params) {
        if (!this.wagmiConfig) {
            throw new Error('connectionControllerClient:walletGetAssets - wagmiConfig is undefined');
        }
        const connections = getConnections(this.wagmiConfig);
        const connection = connections[0];
        const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
        if (!connector) {
            throw new Error('connectionControllerClient:walletGetAssets - connector is undefined');
        }
        const provider = (await connector.getProvider());
        if (!provider) {
            throw new Error('connectionControllerClient:walletGetAssets - provider is undefined');
        }
        return provider.request({ method: 'wallet_getAssets', params: [params] });
    }
    setUniversalProvider(universalProvider) {
        universalProvider.on('connect', () => {
            const connections = getConnections(this.wagmiConfig);
            const connector = this.getWagmiConnector('walletConnect');
            if (connector && !connections.find(c => c.connector.id === connector.id)) {
                reconnect(this.wagmiConfig, {
                    connectors: [connector]
                });
            }
        });
        this.addConnector(new WalletConnectConnector({
            provider: universalProvider,
            caipNetworks: this.getCaipNetworks(),
            namespace: 'eip155'
        }));
    }
}
//# sourceMappingURL=client.js.map